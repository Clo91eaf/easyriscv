<head>
    <title>Easy RISC-V</title>

    <script type="module" src="easyriscv.js"></script>
    <link rel="stylesheet" href="style.css">
    <meta charset='utf-8'>
</head>

<body>
<h1 id="easy-risc-v">Easy RISC-V</h1>
<p>An interactive introduction to RISC-V assembly programming, by <a
href="https://github.com/dramforever">dramforever</a>.</p>
<p>Interested in the code? Want to report an issue? Check out the GitHub
page: <a href="https://github.com/dramforever/easyriscv"
class="uri">https://github.com/dramforever/easyriscv</a></p>
<h2 id="introduction"><a href="#introduction" class="anchor-link"
aria-hidden="true">⋄</a>Introduction</h2>
<p>Inspired by <a href="https://skilldrick.github.io/easy6502/">Easy
6502 by Nick Morgan</a>, this is a quick-ish introduction to RISC-V
assembly programming. This introduction is intended for those with a
basic familiarity with low level computer science concepts, but
unfamiliar with RISC-V. If you’re curious about RISC-V, I hope this will
be a good start to your journey to learning about it.</p>
<p>RISC-V (pronounced “risk-five”), as its name suggests, is <a
href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC
(Reduced instruction set computer)</a> architecture. Having started its
life at UC Berkerley, RISC-V has bred a lively community of students,
researchers, engineers and hobbyists working on software and hardware.
Some highlights of RISC-V include:</p>
<ul>
<li>Clean design: Although loosely based on many previous designs,
RISC-V is at its core a new and clean design. It does away with integer
status flags like “carry” or “overflow”, and does not have MIPS’s branch
delay slots. RISC-V is designed primarily as a target for compilers, but
writing RISC-V assembly by hand is still quite pleasant.</li>
<li>Open standard: RISC-V specifications are developed publicly and
anyone can use them without copyright or patent licensing issues. Many
researchers and companies around the world have made their own RISC-V
processor cores and chips based on these specificaions.</li>
<li>Community support: If you want to make your own processors, rather
than paying a hefty license fee to Arm, or designing your own
architecture, you can just use RISC-V. Using RISC-V instead of a custom
architecture allows you to make use of the existing and growing software
ecosystem instead of having to maintain your own.</li>
</ul>
<p>RISC-V is less mature than more established architectures like x86 or
Arm, but it is already gaining steam real quick and has found great
success in many areas of application, such as embedded systems, custom
processors, education, and research.</p>
<p>This article will cover the 32-bit bare bones RV32I_Zicsr instruction
set with a tiny subset of the privileged architecture. You’ll probably
never find a “real” chip with such bare bones instruction support. Most
of them will have more <em>extensions</em> for other features like
floating point or compressed instructions. However, I would still
consider what we have here a “complete” instruction set. For example,
Rust has <a
href="https://doc.rust-lang.org/nightly/rustc/platform-support/riscv32-unknown-none-elf.html">Tier
2 support</a> for the target <code>riscv32i-unknown-none-elf</code>
which actually works completely fine with only the instructions we’ll
cover here.</p>
<p>Speaking of instructions we will cover, why don’t we meet the 45 of
them right here and now:</p>
<!-- TODO: Ordering? -->
<pre><code>lui auipc jal jalr
beq bne blt bge bltu bgeu
lb lh lw lbu lhu sb sh sw
addi slti sltiu xori ori andi slli srli srai
add sub slt sltu xor or and sll srl sra
ecall ebreak
csrrw csrrs csrrc csrrwi csrrsi csrrci</code></pre>
<p>Some of these instruction names should ring a bell (<code>add</code>,
<code>or</code>, <code>xor</code>). Others will look like they have some
pattern to it. A few weird ones like <code>auipc</code> stand out. These
instructions form the foundation of RISC-V, performing the basic tasks a
processor would do.</p>
<p>You will also catch a glimpse of what creating an operating system on
RISC-V is like, namely handling exceptions and privilege levels.</p>
<p>Let’s get started.</p>
<h2 id="my-first-risc-v-assembly-program"><a
href="#my-first-risc-v-assembly-program" class="anchor-link"
aria-hidden="true">⋄</a>My first RISC-V assembly program</h2>
<p>Throughout this article you will see emulator panes like these:</p>
<p>(If you just see a code block, there’s a JavaScript problem. Make
sure you’ve enabled JavaScript, probably…)</p>
<div class="emulator-disabled">
start:
    addi x10, x0, 0x123
    ebreak
</div>
<p>You can use the buttons to control each emulator. Go ahead and click
on ‘Start’. A register view should pop up showing the state of the
emulator. Now click on ‘Run’. You’ll notice that:</p>
<pre><code>a0 (x10) 0x00000000</code></pre>
<p>Changed into:</p>
<pre><code>a0 (x10) 0x00000123</code></pre>
<p>And the emulator stopped. Congratulations, you’ve run your first
RISC-V assembly program.</p>
<h2 id="emulator-controls"><a href="#emulator-controls"
class="anchor-link" aria-hidden="true">⋄</a>Emulator controls</h2>
<p>‘Start’ assembles your code and, well, starts the emulator. If
there’s a problem with your code, it will tell you about it and the
emulator will not start.</p>
<p>When the emulator is started, you can see the current state of the
registers in the side pane. More controls also becomes available. ‘Run’
runs until the end or until you hit ‘Pause’. ‘Step’ runs a single
step.</p>
<p>If you hit ‘Step’, you’ll notice that the above program takes two
steps to run. You may have guessed correctly that the first step
corresponds to <code>addi</code>, and the second corresponds to
<code>ebreak</code>. The top of the register panel shows
<code>pc</code>, the current instruction address, and in parentheses the
current instruction.</p>
<p>‘Dump’ opens a new window containing some text. There are two
sections: the first is the symbol table, which tells you about the
labels in your code:</p>
<pre><code># Symbols
# 0x40000000 start</code></pre>
<p>The second section is an annotated version of your code:</p>
<pre><code>start:
{ 0x40000000: 12300513 } addi x10, x0, 0x123
{ 0x40000004: 00100073 } ebreak</code></pre>
<p>This tells you that the <code>addi</code> instruction encodes to hex
<code>12300513</code>, and starts at address hex <code>40000000</code>.
Similarly, <code>ebreak</code> encodes as <code>00100073</code> at
address hex <code>40000004</code>.</p>
<p>(Note: RISC-V instructions are <em>little-endian</em>, meaning that
the four bytes of <code>addi</code> are actually
<code>13 05 30 12</code>.)</p>
<p>We’ll talk in detail about all of <code>pc</code>, registers,
instructions, labels, and the two checkboxes later.</p>
<p>Now you may have also guessed that <code>addi x10, x0, 0x123</code>
means <code>x10 = x0 + 0x123</code>. As of <code>ebreak</code>, for now,
just remember that <code>ebreak</code> stops the emulator.</p>
<h2 id="processor-state"><a href="#processor-state" class="anchor-link"
aria-hidden="true">⋄</a>Processor state</h2>
<!-- TODO: Rewrite this section so it doesn't look like it's about the emulator -->
<p>Why don’t we start with the register view that shows the internal
state of the processor.</p>
<p>On the top of the register view is <code>pc</code>. The <span
id="term-program-counter"><em>program counter</em></span>, or <span
id="term-pc"><em><code>pc</code></em></span> is the address of the
current instruction. (The instruction listed in parenthesis next to
<code>pc</code> in the register view is provided as a courtesy and is
not part of the processor state.)</p>
<p>After that, 31 <span id="term-general-purpose-registers"><em>general
purpose registers</em></span> are listed, numbered <span
id="reg-x1-through-x31"><em><code>x1</code> through
<code>x31</code></em></span>. These can contain any 32-bit data.</p>
<p>(If you’re wondering, there are no flags for RV32I.)</p>
<p>You may have noticed I’ve omitted one register. The register <span
id="reg-x0"><em><code>x0</code></em></span> is a special “zero
register”. For computational instructions, you can use <code>x0</code>
anywhere a register is expected. Reading it always gives zero, and
writing to it just gets ignored. The use of a special register
simplifies the design of the architecture, and this use is shared by
MIPS and Arm AArch64. We will make good use of <code>x0</code> soon.</p>
<h2 id="instruction-syntax"><a href="#instruction-syntax"
class="anchor-link" aria-hidden="true">⋄</a>Instruction syntax</h2>
<p>But before we can start talking about instructions themselves, we
need a way to talk about the <span
id="term-instruction-syntax"><em>instruction syntax</em></span> so I
can, you know, write it down for you.</p>
<p>The syntax of an instruction is the instruction name and then several
comma-separated operands. For example, for this instruction we’ve seen
above:</p>
<pre><code>addi x10, x0, 0x123</code></pre>
<p><code>x10</code> is the <span
id="term-destination-register"><em>destination register</em></span> or
<span id="term-rd"><em><code>rd</code></em></span>. The next operand is
the first (and only) <span id="term-source-register"><em>source
register</em></span> or <span
id="term-rs1"><em><code>rs1</code></em></span>. The last operand is an
<span id="term-immediate-value"><em>immediate value</em></span> or <span
id="term-imm"><em><code>imm</code></em></span>. Using these
abbreviations, we can summarize that the syntax for <code>addi</code>
is:</p>
<pre><code>addi rd, rs1, imm</code></pre>
<p>Some other instructions have a second source register or <span
id="term-rs2"><em><code>rs2</code></em></span>. For example, the
non-immediate <code>add</code> instruction has this syntax:</p>
<pre><code>add rd, rs1, rs2</code></pre>
<p>Some other instructions have no operands, like <code>ebreak</code>.
Others have slightly more complex operands.</p>
<h2 id="computational-instructions"><a
href="#computational-instructions" class="anchor-link"
aria-hidden="true">⋄</a>Computational instructions</h2>
<p>Using the registers as a playground of numbers, we can use
computational instructions to work with them.</p>
<h3 id="arithmetic-instructions">Arithmetic instructions</h3>
<p>As we’ve seen above, you can get a RISC-V machine to add numbers
together.</p>
<p>The <span id="insn-addi"><em><code>addi</code></em></span>
instruction adds the value in <code>rs1</code> to the immediate value
<code>imm</code>, and puts the result in <code>rd</code>.</p>
<pre><code>addi rd, rs1, imm</code></pre>
<p>The <span id="insn-add"><em><code>add</code></em></span> instruction
adds the value in <code>rs1</code> to the value in <code>rs2</code>, and
puts the result in <code>rd</code>.</p>
<pre><code>add rd, rs1, rs2</code></pre>
<p>The opposite of addition is subtraction. The <span
id="insn-sub"><em><code>sub</code></em></span> instruction subtracts the
value in <code>rs2</code> from the value in <code>rs1</code>
(i.e. <code>rs1 - rs2</code>), and puts the result in <code>rd</code>.
There’s no corresponding <code>subi</code> instruction — Just use
<code>addi</code> with a negative number.</p>
<pre><code>sub rd, rs1, rs2</code></pre>
<p>Step through this demo program and try writing your own additions and
subtractions:</p>
<div class="emulator-disabled">
    addi x10, x0, 0x123
    addi x11, x0, 0x555

    addi x12, x10, 0x765
    add x13, x10, x11
    sub x14, x11, x10

    addi x10, x10, 1
    addi x10, x10, 1
    addi x10, x10, -1
    addi x10, x10, -1

    ebreak
</div>
<p>One thing you should note is that the immediate value has a limited
range, namely <code>[-2048, 2047]</code>, the range of a 12-bit two’s
complement signed integer. This is because RV32I uses fixed 32-bit
i.e. 4-byte instructions, and only the top 12 bits are available to
encode an immediate value. You can see the hexadecimal value encoded in
the instruction from the ‘Dump’. This article will not go into much
further detail about instruction encodings.</p>
<pre><code>{ 0x40000000: 12300513 } addi x10, x0, 0x123
{ 0x40000004: 55500593 } addi x11, x0, 0x555</code></pre>
<p>Even instructions as simple as addition and subtraction have other
interesting uses. We have already used <code>addi x10, x0, 0x123</code>
to put <code>0x123</code> in the register <code>x10</code>. When writing
in assembly, we can use a little shortcut called <span
id="term-pseudoinstructions"><em>pseudoinstructions</em></span>. The
<span id="insn-li"><em><code>li</code></em></span> (“load immediate”)
pseudoinstruction is a convenient way to put a small value in a
register. It expands to <code>addi rd, x0, imm</code> when
<code>imm</code> is in the range <code>[-2048, 2047]</code>.</p>
<pre><code>li rd, imm</code></pre>
<p>When <code>imm</code> is <code>0</code>, <code>addi</code> copies the
value without changing it because adding zero is the same as doing
nothing. The <span id="insn-mv"><em><code>mv</code></em></span> (“move”)
pseudoinstruction copies the value from <code>rs1</code> to
<code>rd</code>. It expands to <code>addi rd, rs1, 0</code>.</p>
<pre><code>mv rd, rs1</code></pre>
<p>Using the pseudoinstruction vs the “real” instruction are equivalent.
You can see in the dump that the two are assembled exactly the same
way.</p>
<div class="emulator-disabled">
    addi x10, x0, 0x123
    li x10, 0x123

    addi x11, x10, 0
    mv x11, x10

    ebreak
</div>
<p>Subtracting from zero is negation. What’s negative of
<code>0x123</code>?</p>
<div class="emulator-disabled">
    li x10, 0x123
    sub x11, x0, x10

    ebreak
</div>
<p>Hmm, we get <code>0xfffffccd</code>. That’s the 32-bit <span
id="term-two’s-complement"><em>two’s complement</em></span>
representation of <code>-291</code> or <code>-0x123</code>. There’s
plenty of tutorials on this out there, so we’ll just note that whenever
something is “signed”, RISC-V uses two’s complement representation. The
benefit of this is that there’s less instructions for separate signed
and unsigned instructions — both signed and unsigned numbers have the
same overflow wrap-around behavior.</p>
<p>Speaking of overflow wrap-around, what happens if we add something
too much and it overflows? We’ll use <code>add</code> to repeatedly
double <code>0x123</code> and see what happens:</p>
<div class="emulator-disabled">
    li x10, 0x123
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10

    ebreak
</div>
<p>As <code>0x123</code> crawls up to the upper bits and eventually we
get to <code>0x9180_0000</code>, in the next iteration it turns into
<code>0x2300_0000</code>. There was an overflow! Double of
<code>0x9180_0000</code> is <code>0x1_2300_0000</code>, but that needs
33 bits in binary, so the highest bit can’t be put in the result. Since
RISC-V doesn’t have flag bits for carry or overflow, it’s simply gone.
The programmer is expected to deal with this.</p>
<h3 id="bitwise-instructions">Bitwise instructions</h3>
<p>While we’re talking about bits, another thing we can do about bits is
doing bitwise logical operations on them.</p>
<p>The <span id="insn-and"><em><code>and</code></em></span> instruction
performs a bitwise-“and” between the bits of <code>rs1</code> and
<code>rs2</code> and puts the result in <code>rd</code>. The <span
id="insn-or"><em><code>or</code></em></span> and <span
id="insn-xor"><em><code>xor</code></em></span> instructions similarly
performs bitwise-“or” and bitwise-“xor”, respectively.</p>
<pre><code>and rd, rs1, rs2
or rd, rs1, rs2
xor rd, rs1, rs2</code></pre>
<p>Immediate operand versions of the three, namely <span
id="insn-andi"><em><code>andi</code></em></span>, <span
id="insn-ori"><em><code>ori</code></em></span>, <span
id="insn-xori"><em><code>xori</code></em></span> also exist.</p>
<pre><code>andi rd, rs1, imm
ori rd, rs1, imm
xori rd, rs1, imm</code></pre>
<p>Here are some random bit operation examples you can play with:</p>
<div class="emulator-disabled">
    li x10, 0x5a1
    xori x10, x10, 0xf0
    xori x10, x10, -1

    li x11, 0x5a1
    addi x12, x11, -1
    and x11, x11, x12
    addi x12, x11, -1
    and x11, x11, x12
    addi x12, x11, -1
    and x11, x11, x12

    li x13, 0x5a1
    ori x14, x13, 0xf
    ori x14, x13, 0xff
    ori x14, x13, 0xf0

    ebreak
</div>
<p>Remember that the immediate value is in the range
<code>[-2048, 2047]</code>. For negative values, the two’s complement
representation used means that the high bits are all ones. For example,
using <code>-1</code> as <code>imm</code> means the second operand is
binary all ones, or <code>0xffff_ffff</code>. This allows us to use
<code>xori rd, rs1, -1</code> as bitwise-“not”.</p>
<div class="emulator-disabled">
    li x10, 0x5a1
    xori x11, x10, -1

    or x12, x10, x11
    add x13, x10, x11

    ebreak
</div>
<p>Another interesting operation you can do is to round/<span
id="term-align"><em>align</em></span> something up or down to a multiple
of a power of two. For example, if you want to find the closest multiple
of 16 below <code>a</code>, in binary that would be clearing the lowest
4 bits, or <code>a &amp; ~0b1111</code>. Conveniently, that’s
<code>a &amp; -16</code> in two’s complement.</p>
<p>Aligning up is less intuitive, but one idea would be adding 16 first.
However that gives an incorrect result for powers of 16. It’s easy
enough to fix though: adding one less works exactly right:
<code>(a + 15) &amp; -16</code></p>
<div class="emulator-disabled">
    li x10, 0x123
    andi x11, x10, -16

    addi x12, x10, 15
    andi x12, x12, -16
    ebreak
</div>
<h3 id="comparison-instructions">Comparison instructions</h3>
<p>Usually when you write a comparison of some sort like
<code>a == b</code> or <code>a &gt;= b</code>, it’s used as a condition
for some <code>if</code> or loop, but… those things are complicated!
We’re getting to it later.</p>
<p>Sometimes you just want a boolean value out of a comparison. The C
convention uses 1 for true and 0 for false, and since the world runs on
C now, that’s what RISC-V provides.</p>
<p>In C there are six comparison operators:</p>
<pre><code>== != &lt; &gt; &lt;= &gt;=</code></pre>
<p>The values being compared can also be both signed or both
unsigned.</p>
<p>How many comparison instructions do we have at our disposal? Let’s
see…</p>
<p>The <span id="insn-slt"><em><code>slt</code></em></span> (“set less
than”) instruction compares <code>rs1</code> and <code>rs2</code> as
signed 32-bit integers, and sets <code>rd</code> to <code>1</code> if
<code>rs1 &lt; rs2</code>, and <code>0</code> otherwise
(<code>rs1 &gt;= rs2</code>). The <span
id="insn-sltu"><em><code>sltu</code></em></span> instruction is similar
but it treats the operands as unsigned values. <span
id="insn-slti"><em><code>slti</code></em></span> and <span
id="insn-sltiu"><em><code>sltiu</code></em></span> are similar but the
second operand is an immediate value.</p>
<pre><code>slt rd, rs1, rs2
sltu rd, rs1, rs2
slti rd, rs1, imm
sltiu rd, rs1, imm</code></pre>
<p>(Of particular note is <code>sltiu</code>, where the immediate
operand still has the range <code>[-2048, 2047]</code> but is sign
extended to 32 bits and then treated as an unsigned value, like what
would happen in C with <code>a &lt; (unsigned)-1</code>.)</p>
<p>That’s… one of the six comparisons settled. What about the others? As
it turns out, we can synthesize any of the other five, using up to two
instructions.</p>
<p>Making <code>&gt;</code> from <code>&lt;</code> is easy, as you can
just swap the operands. Using <code>xori</code> with <code>1</code> we
can invert the result of a comparison, giving as <code>&lt;=</code> and
<code>&gt;=</code>.</p>
<div class="emulator-disabled">
    li x10, 0x3
    li x11, 0x5

    slt x12, x10, x11   # x10 &lt; x11
    slt x13, x11, x10   # x10 &gt; x11

    xori x14, x12, 1    # x10 &gt;= x11  i.e.  !(x10 &lt; x11)
    xori x15, x13, 1    # x10 &lt;= x11  i.e.  !(x10 &gt; x11)

    ebreak
</div>
<p>That was signed comparison but unsigned comparison works the same
using <code>sltu</code> instead of <code>slt</code>.</p>
<p>As for <code>==</code> and <code>!=</code>, let’s tackle the easier
case of <code>a == 0</code> and <code>a != 0</code> first. We will use
the fact that for unsigned values, <code>a != 0</code> is equivalent to
<code>a &gt; 0</code>. The negation of that is <code>a &lt;= 0</code>,
which is the same as <code>a &lt; 1</code>.</p>
<div class="emulator-disabled">
    li x10, 0

    sltu x11, x0, x10   # 0 &lt;u x10  i.e.  x10 != 0
    sltiu x12, x10, 1   # x10 &lt;u 1  i.e.  x10 == 0
</div>
<p>As a bonus, this is also how we get logical not and converting
integer to boolean.</p>
<p>Now that we have these, <code>a == b</code> is just
<code>(a - b) == 0</code>, and <code>a != b</code> is just
<code>(a - b) != 0</code>.</p>
<div class="emulator-disabled">
    li x10, 0x3         # a
    li x11, 0x5         # b
    sub x10, x10, x11   # x10 = a - b

    sltu x11, x0, x10   # 0 &lt;u x10  i.e.  x10 != 0
    sltiu x12, x10, 1   # x10 &lt;u 1  i.e.  x10 == 0

    ebreak
</div>
<p>In summary: (<code>[u]</code> means use <code>u</code> for unsigned
comparison and nothing for signed comparison)</p>
<ul>
<li><code>a &lt; b</code>: <code>slt[u]</code></li>
<li><code>a &gt; b</code>: <code>slt[u] reversed</code></li>
<li><code>a &lt;= b</code>: <code>slt[u] reversed ; xori 1</code></li>
<li><code>a &gt;= b</code>: <code>slt[u] ; xori 1</code></li>
<li><code>a == 0</code>: <code>sltu x0</code></li>
<li><code>a != 0</code>: <code>sltiu 1</code></li>
<li><code>a == b</code>: <code>sub ; sltu x0</code></li>
<li><code>a != b</code>: <code>sub ; sltiu 1</code></li>
</ul>
<h3 id="shift-instructions">Shift instructions</h3>
<p>There is no way I can do justice to the usage of bit shifts in the
middle of a tutorial on RISC-V assembly. If you’re here, you’ve probably
heard of them. There’s nothing really special to the way they appear in
usage for RISC-V.</p>
<p>There are two variants for right shifting: <span
id="insn-srl"><em><code>srl</code></em></span> and <span
id="insn-srli"><em><code>srli</code></em></span> (“shift right logical
(immediate)”) performs “logical” or unsigned right shift where the
leftmost or most significant bits are filled with zeros.</p>
<p><span id="insn-sra"><em><code>sra</code></em></span> and <span
id="insn-srai"><em><code>srai</code></em></span> (“shift right
arithmetic (immediate)”) performs “arithmetic” or signed right shift
where the leftmost bits are filled with the same of what highest/sign
bit was. So if you shift a negative value, you get a negative result; if
you shift a non-negative value, you get a non-negative result.</p>
<pre><code>srl rd, rs1, rs2
sra rd, rs1, rs2
srli rd, rs1, imm
srai rd, rs1, imm</code></pre>
<p>As before, the ones with the <code>i</code> suffix take an immediate
value as the second operand, and the ones without <code>i</code> take a
register.</p>
<div class="emulator-disabled">
    li x10, -3
    srai x11, x10, 16
    srli x12, x10, 16
    ebreak
</div>
<p>So <code>a</code> means “arithmetic”, <code>l</code> means “logical”.
Got it.</p>
<p>Left shifts have no such distinction. For consistency they are still
“logical”: <span id="insn-sll"><em><code>sll</code></em></span> is left
shift, and <span id="insn-slli"><em><code>slli</code></em></span> is
left shift with immediate.</p>
<pre><code>sll rd, rs1, rs2
slli rd, rs1, imm</code></pre>
<p>Aha, now we can blow up <code>0x123</code> without repeating myself
so much:</p>
<div class="emulator-disabled">
    li x10, 0x123
    slli x10, x10, 10
    slli x10, x10, 10
    slli x10, x10, 10
    ebreak
</div>
<p>The immediate value for shift instructions are special: they can only
be in the range of 0 to 31, inclusive, because it doesn’t make sense to
shift by a negative amount, or by more than 31. When the shift amount is
taken from a register, the value is considered modulo 32, or in other
words only the last 5 bits are taken into account:</p>
<div class="emulator-disabled">
    li x10, 0x444
    li x11, 0x81

    srl x10, x10, x11   # Same as shifting by 1

    ebreak
</div>
<p>For some fun, let’s try multiplying a value by 10, something you
would do when parsing decimal numbers: <code>a * 10</code> can be
rewritten as <code>(a &lt;&lt; 1) + (a &lt;&lt; 3)</code>:</p>
<div class="emulator-disabled">
    li x10, 0x5

    slli x11, x10, 1
    slli x12, x10, 3
    add x11, x11, x12

    ebreak
</div>
<h3 id="thats-it">That’s it…?</h3>
<p>That’s it?</p>
<p>You may have noticed some glaring omissions. What we’ve learned
doesn’t even cover grade school math: multiplication and division are
missing.</p>
<p>RISC-V is designed with <span
id="term-extensions"><em>extensions</em></span> in mind. Remember that
as said in the introduction, RV32I is the barest bones of the barest
bones we’ve got. Forcing everyone to make their processors with
multiplication and division even for tasks that don’t need them would
waste silicon area and money on every chip. Instead those making RISC-V
processors have great freedom to choose, and indeed some would say, they
have too much freedom.</p>
<p>For us… Honestly, I’m just glad we’ve been dealt a hand that we can
tackle completely in full. There’s no way I’m finishing writing this
tutorial if it were more full-fledged.</p>
<h3 id="summary-of-computational-instructions">Summary of computational
instructions</h3>
<p>(Operand <code>a</code> is <code>rs1</code>, and <code>b</code> is
<code>rs2</code> or immediate. In the instruction name <code>[i]</code>
means an immediate variant is available. Subscript <code>u</code> means
unsigned and <code>s</code> means two’s complement signed.)</p>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 40%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Instruction</th>
<th>Operation</th>
<th>Immediate range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>add[i]</code></td>
<td><code>a + b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr class="even">
<td><code>sub</code></td>
<td><code>a - b</code></td>
<td>(n/a)</td>
</tr>
<tr class="odd">
<td><code>slt[i]</code></td>
<td><code>(a &lt;<sub>s</sub> b) ? 1 : 0</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr class="even">
<td><code>slt[i]u</code></td>
<td><code>(a &lt;<sub>u</sub> b) ? 1 : 0</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr class="odd">
<td><code>xor[i]</code></td>
<td><code>a ^ b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr class="even">
<td><code>or[i]</code></td>
<td><code>a | b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr class="odd">
<td><code>and[i]</code></td>
<td><code>a &amp; b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr class="even">
<td><code>sll[i]</code></td>
<td><code>a &lt;&lt; b</code></td>
<td><code>[0, 31]</code></td>
</tr>
<tr class="odd">
<td><code>srl[i]</code></td>
<td><code>a &gt;&gt;<sub>u</sub> b</code></td>
<td><code>[0, 31]</code></td>
</tr>
<tr class="even">
<td><code>sra[i]</code></td>
<td><code>a &gt;&gt;<sub>s</sub> b</code></td>
<td><code>[0, 31]</code></td>
</tr>
</tbody>
</table>
<h2 id="intermission-larger-numbers"><a
href="#intermission-larger-numbers" class="anchor-link"
aria-hidden="true">⋄</a>Intermission: Larger numbers</h2>
<p>The <code>addi</code> instruction has limit on the immediate value.
How do we make bigger values?</p>
<p>The <span id="insn-lui"><em><code>lui</code></em></span> (“load upper
immediate”) instruction takes an immediate in the range
<code>[0, 1048575]</code> (i.e. up to <code>2<sup>20</sup> - 1</code>)
and sets <code>rd</code> to that value left shifted 12 bits:</p>
<pre><code>lui rd, imm20</code></pre>
<p>That was… slightly confusing. Why don’t we give it a try:</p>
<div class="emulator-disabled">
    lui x10, 1
    lui x11, 2
    ebreak
</div>
<p>Instead of <code>li</code> loading a “low” immediate, we control the
<em>upper</em> 20 bits of what we put in the register. After that, we
can use another <code>addi</code> instruction to fill in the lower bits.
For example, if we want <code>0x12345</code>:</p>
<div class="emulator-disabled">
    lui x10, 0x12
    addi x10, x10, 0x345
    ebreak
</div>
<p>For convenience, in assembly you can use <code>%hi()</code> and
<code>%lo()</code> to extract the, well, high 20 and low 10 bits of a
value. The previous example could also be written:</p>
<div class="emulator-disabled">
    lui x10, %hi(0x12345)
    addi x10, x10, %lo(0x12345)
    ebreak
</div>
<p>Letting <code>lui</code> handle the high 20 bits, and
<code>addi</code> for the low 12 bits, you can make any 32-bit
value.</p>
<p>(A small complication arises if you want to use values with bit 11
set. In that case, the immediate operand to <code>addi</code> will have
to be negative. However <code>%hi</code> understands this and adds one
to compensate, so this <code>%hi</code>/<code>%lo</code> combination
does work for everything.)</p>
<h2 id="jumps-and-branches"><a href="#jumps-and-branches"
class="anchor-link" aria-hidden="true">⋄</a>Jumps and branches</h2>
<p>So far, everything that we’ve had so far can be done on even the most
basic programmer’s calculator. To truly make a computer… do computer
stuff, we’d want loops and conditionals.</p>
<p>In RISC-V parlance, a <span id="term-branch"><em>branch</em></span>
is a conditional transfer of control flow, and a <span
id="term-jump"><em>jump</em></span> is an unconditional transfer of
control flow.</p>
<p>I think the branch instructions are slightly simpler, so let’s start
with those.</p>
<h3 id="branches">Branches</h3>
<p>All the branch instruction follow the form “If some comparison, go to
somewhere.” The conditions are:</p>
<ul>
<li><span id="insn-beq"><em><code>beq</code></em></span>:
<code>rs1 == rs2</code> (“equal”)</li>
<li><span id="insn-bne"><em><code>bne</code></em></span>:
<code>rs1 != rs2</code> (“not equal”)</li>
<li><span id="insn-blt"><em><code>blt</code></em></span>:
<code>rs1 &lt; rs2</code> signed (“less than”)</li>
<li><span id="insn-bge"><em><code>bge</code></em></span>:
<code>rs1 &gt;= rs2</code> signed (“greater or equal”)</li>
<li><span id="insn-bltu"><em><code>bltu</code></em></span>:
<code>rs1 &lt; rs2</code> signed (“less than unsigned”)</li>
<li><span id="insn-bgeu"><em><code>bgeu</code></em></span>:
<code>rs1 &gt;= rs2</code> signed (“greater or equal unsigned”)</li>
</ul>
<p>(In case you’re wondering about the confusing choice of ordering
operators here, it’s just that the negation of <code>&lt;</code> is
<code>&gt;=</code>.)</p>
<pre><code>beq rs1, rs2, label
bne rs1, rs2, label
blt rs1, rs2, label
bge rs1, rs2, label
bltu rs1, rs2, label
bgeu rs1, rs2, label</code></pre>
<p>Oh, right, almost forgot to explain what labels are. Labels are
convenience identifiers for addresses at some line of your code. They
are some identifier followed by a colon (like <code>this:</code>). They
can appear on a line of its own, or before any instruction on the line.
You can see which address they point to using the “Dump” button. The
third operand of a branch instruction is a label to jump to if the
condition holds.</p>
<p>Let’s add up all the numbers from 1 to 100:</p>
<div class="emulator-disabled">
    li x10, 100         # i = 100
    li x11, 0           # sum = 0

loop:
    add x11, x11, x10   # sum = sum + i
    addi x10, x10, -1   # i = i - 1
    blt x0, x10, loop   # If i &gt; 0: loop again
                        # Otherwise: done

    ebreak
</div>
<h1 id="index">Index</h1>
<ul>
<li><a href="#term-align">align</a></li>
<li><a href="#term-branch">branch</a></li>
<li><a href="#term-destination-register">destination register</a></li>
<li><a href="#term-extensions">extensions</a></li>
<li><a href="#term-general-purpose-registers">general purpose
registers</a></li>
<li><a href="#term-imm"><code>imm</code></a></li>
<li><a href="#term-immediate-value">immediate value</a></li>
<li><a href="#term-instruction-syntax">instruction syntax</a></li>
<li><a href="#term-jump">jump</a></li>
<li><a href="#term-pc"><code>pc</code></a></li>
<li><a href="#term-program-counter">program counter</a></li>
<li><a href="#term-pseudoinstructions">pseudoinstructions</a></li>
<li><a href="#term-rd"><code>rd</code></a></li>
<li><a href="#term-rs1"><code>rs1</code></a></li>
<li><a href="#term-rs2"><code>rs2</code></a></li>
<li><a href="#term-source-register">source register</a></li>
<li><a href="#term-two’s-complement">two’s complement</a></li>
</ul>
<ul>
<li><a href="#reg-x0"><code>x0</code></a></li>
<li><a href="#reg-x1-through-x31"><code>x1</code> through
<code>x31</code></a></li>
</ul>
<ul>
<li><a href="#insn-add"><code>add</code></a></li>
<li><a href="#insn-addi"><code>addi</code></a></li>
<li><a href="#insn-and"><code>and</code></a></li>
<li><a href="#insn-andi"><code>andi</code></a></li>
<li><a href="#insn-beq"><code>beq</code></a></li>
<li><a href="#insn-bge"><code>bge</code></a></li>
<li><a href="#insn-bgeu"><code>bgeu</code></a></li>
<li><a href="#insn-blt"><code>blt</code></a></li>
<li><a href="#insn-bltu"><code>bltu</code></a></li>
<li><a href="#insn-bne"><code>bne</code></a></li>
<li><a href="#insn-li"><code>li</code></a></li>
<li><a href="#insn-lui"><code>lui</code></a></li>
<li><a href="#insn-mv"><code>mv</code></a></li>
<li><a href="#insn-or"><code>or</code></a></li>
<li><a href="#insn-ori"><code>ori</code></a></li>
<li><a href="#insn-sll"><code>sll</code></a></li>
<li><a href="#insn-slli"><code>slli</code></a></li>
<li><a href="#insn-slt"><code>slt</code></a></li>
<li><a href="#insn-slti"><code>slti</code></a></li>
<li><a href="#insn-sltiu"><code>sltiu</code></a></li>
<li><a href="#insn-sltu"><code>sltu</code></a></li>
<li><a href="#insn-sra"><code>sra</code></a></li>
<li><a href="#insn-srai"><code>srai</code></a></li>
<li><a href="#insn-srl"><code>srl</code></a></li>
<li><a href="#insn-srli"><code>srli</code></a></li>
<li><a href="#insn-sub"><code>sub</code></a></li>
<li><a href="#insn-xor"><code>xor</code></a></li>
<li><a href="#insn-xori"><code>xori</code></a></li>
</ul>
